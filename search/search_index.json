{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Accueil","text":""},{"location":"#accueil","title":"Accueil","text":""},{"location":"#structure-du-cours","title":"Structure du cours","text":"<p>Le cours est structur\u00e9 de la mani\u00e8re suivante :</p> <ul> <li>3 cours magistraux (3 x 1h30)</li> <li>2 TP (4h30) </li> <li>2 cours magistraux (2 x 1h30) </li> <li>1 TP (4h30)</li> <li>2 cours magistraux (2 x 1h30) </li> <li>2 TP (4h30) </li> </ul>"},{"location":"#sujets-de-betp","title":"Sujets de BE/TP","text":"<p>Tout au long de ces TP, vous allez construire votre propre ordinateur. Cet ordinateur sera simul\u00e9 \u00e0 l'aide du logiciel logisim. Logisim est un simulateur de circuits logiques initialement d\u00e9velopp\u00e9 par C. Burch, qui a interrompu son d\u00e9veloppement et nous utiliserons le fork logisim-evolution.</p> <p>Ce simulatateur dispose de tout les \u00e9l\u00e9ments n\u00e9cessaires \u00e0 la compr\u00e9hension du fonctionnement d'un microprocesseur ou microcontr\u00f4leur. En construisant petit \u00e0 petit une architecture de plus en plus complexe, on abordera les questions suivantes:</p> <ul> <li>les composants constituants un microprocesseur : m\u00e9moire, registres, unit\u00e9 arithm\u00e9tique et logique et leur coordination : S\u00e9quenceur manuel (TP)</li> <li>le s\u00e9quencement automatique du chemin de donn\u00e9es : S\u00e9quenceur microprogramm\u00e9 (TP)</li> <li>la pile et l'appel de routines: Pile et appel de routines (TP)</li> <li>la gestion des entr\u00e9es par interruption :Interruptions (TP)</li> <li>la programmation assembleur et l'ordonnancement dans un syst\u00e8me multiprocessus : Programmation assembleur et ordonnanceur (TP)</li> </ul> <p>Ci-dessous, une petite vid\u00e9o illutre en fonctionnement l'architecture que nous allons construire et \u00e9tudier.</p>   Download the WEBM video.  <p>Logisim est install\u00e9 sur les postes de travail. Si vous souhaitez l'utiliser chez vous, il vous faut r\u00e9cup\u00e9rer l'installeur mis \u00e0 disposition dans les releases de logisim evolution : https://github.com/logisim-evolution/logisim-evolution/releases</p> <p>Note</p> <p>Notez au passage qu'il existe plusieurs versions de logisim sur Internet. La version initiale d\u00e9velopp\u00e9 par C. Burch, dont il a arr\u00eat\u00e9 le d\u00e9veloppement en 2014. Il y a eu le fork de jlawrence qui a fix\u00e9 quelques bugs r\u00e9siduels mais qui ne re\u00e7oit plus de mise \u00e0 jour depuis 2016. Et il y a logisim-evolution qui continue \u00e0 \u00eatre mis \u00e0 jour.</p>"},{"location":"#demarrer-la-version-jar-de-logisim-sous-ubuntu","title":"D\u00e9marrer la version JAR de logisim sous Ubuntu","text":"<p>Si vous utilisez la version jar de logisim, pour la d\u00e9marrer, il suffit de taper la commande suivante dans un terminal :</p> <ul> <li>Se connecter sur une machine ubuntu</li> <li>Lancer un terminal en appuyant Ctrl + Alt + T</li> <li>Saisir, dans le terminal, la commande : java -jar /opt/logisim-evolution-3.9.0-all.jar</li> <li>le simulateur devrait se lancer</li> </ul> <p>Pour vous simplifier l'ex\u00e9cution ult\u00e9rieure de logisim, lorsque logisim est lanc\u00e9 pour la premi\u00e8re, une icone appara\u00eet dans la liste des applications \u00e0 gauche de l'\u00e9cran. Cliquez avec le bouton droit sur cette ic\u00f4ne et s\u00e9lectionnez \"L'attacher au lanceur\". Les prochaines fois, vous n'aurez plus besoin de d\u00e9marrer de terminal pour lancer logisim, il vous suffira de cliquer sur l'ic\u00f4ne.</p> <p>Pour d\u00e9marrer un \u00e9diteur de texte, il faut:</p> <ul> <li>Lancer un terminal (Ctrl + Alt + T) ou ouvrir un nouvel onglet dans un terminal d\u00e9j\u00e0 ouvert : s\u00e9lectionner le terminal et presser Ctrl + Shift + T</li> <li>Saisir, dans le terminal, la commande : gedit</li> <li>l'\u00e9diteur de texte devrait se lancer</li> </ul>"},{"location":"irq/","title":"Interruptions (TP 4)","text":""},{"location":"irq/#interruptions-tp-4","title":"Interruptions (TP 4)","text":""},{"location":"irq/#introduction","title":"Introduction","text":"<p>Jusqu'\u00e0 maintenant, notre architecture vit dans son monde, elle est quasiment incapable de s'interfacer avec le monde ext\u00e9rieur. Nous avons en v\u00e9rit\u00e9 d\u00e9j\u00e0 vus quelques sorties avec les afficheurs 7 segments mais elle n'est pas sensible \u00e0 des entr\u00e9es. On va ici \u00e9tudier comment ajouter des p\u00e9riph\u00e9riques d'entr\u00e9e et \u00eatre capable de r\u00e9pondre \u00e0 des \u00e9v\u00e9nements asynchrones (e.g. l'appui sur un bouton) produits lorsque ces p\u00e9riph\u00e9riques sont utilis\u00e9s. On va voir notamment:</p> <ul> <li>le principe des interruptions</li> <li>le codage des gestionnaires d'interruption (interrupt handlers)</li> <li>la gestion d'une interruption pendant l'ex\u00e9cution d'un programme</li> </ul> <p>L'architecture que je vous propose d'utiliser est repr\u00e9sent\u00e9e ci-dessous. Vous y verrez notamment l'ajout d'un registre (Interrupt Flag) ainsi que quatre signaux de contr\u00f4le INTA, SetIF, ClearIF, ReadINTAdr. Vous y verrez \u00e9galement un petit circuit (\u00e0 c\u00f4t\u00e9 de la RAM) permettant de g\u00e9n\u00e9rer une interruption lors de l'appui sur un bouton et une modification du contr\u00f4le du multiplexeur du MicroPC. T\u00e9l\u00e9chargez le fichier archi_irq.circ ainsi que le fichier csmetz.jar \u00e0 placer dans le m\u00eame r\u00e9pertoire que archi_irq.circ. Ouvrez le circuit avec logisim. Chargez la ROM microcode_irq.rom qui contient les micro-instructions des instructions introduites dans le sujet pr\u00e9c\u00e9dent.</p> <p>Je vous rappelle que vous disposez de la carte de r\u00e9f\u00e9rence de l'architecture. </p> <p></p>"},{"location":"irq/#le-principe-des-interruptions","title":"Le principe des interruptions","text":"<p>Le registre Interrupt Flag est l\u00e0 pour autoriser ou non les interruptions. En effet, si, par exemple, le pointeur de pile n'est pas encore initialis\u00e9, il ne faut surtout pas partir en interruption puisque c'est justement sur la pile qu'on m\u00e9morise le contenu des registres en quittant la routine d'interruption. Au d\u00e9marrage de la machine, ce registre est \u00e0 0, on s'assurera d'autoriser les interruptions apr\u00e8s l'initialisation. On introduit deux instructions pour g\u00e9rer l'\u00e9tat de ce registre ainsi que deux instructions pour partir en interruption et revenir d'une interruption.</p> Code Op\u00e9ration (8 bits) Nom de l'op\u00e9ration Nombre de mots Description 0xd0 CLI 1 Met \u00e0 z\u00e9ro le registre Interrupt Flag (IF).IF := 0. 0xd4 STI 1 Met \u00e0 un le registre Interrupt Flag (IF).IF := 1. 0xe0 INT 1 D\u00e9part en interruption. Le vecteur d'interruption doit \u00eatre en RAM \u00e0 l'adresse 0x0002. Cette adresse est chargeable dans le PC via le signal de contr\u00f4le ReadINTAdr. 0xe8 RTI 1 Retour d'une interruption en reprenant le d\u00e9roulement du programme interrompu. <p>On pourrait appeler depuis un programme l'interruption (en invoquant INT) mais on va ici voir comment partir en interruption lors qu'on appui sur le bouton. Si le bouton est press\u00e9, alors INTR = 1. La d\u00e9tection d'une interruption se fait avant l'ex\u00e9cution de chaque instruction du programme principal (\u00e0 l'adresse 0x00 de la ROM) avec des signaux CodeMCount particulier. Je vous rappelle la s\u00e9mantique de CodeMCount qui permet de piloter le multiplexeur du MicroPC:</p> <ul> <li>Si CodeMCount=0b000, alors SMux=MicroPC+1 </li> <li>Si CodeMCount=0b001, alors SMux=@Adr </li> <li>Si CodeMCount=0b010, alors SMux=InstCode </li> <li>Si CodeMCount=0b011 et Z=0, alors SMux=MicroPC+1 </li> <li>Si CodeMCount=0b011 et Z=1, alors SMux=@Adr </li> </ul> <p>On y ajoute les codes suivants :</p> <ul> <li>Si CodeMCount=0b100 et INTR &amp; IF=0, alors SMux=@Adr</li> <li>Si CodeMCount=0b100 et INTR &amp; IF=1, alors SMux=MicroPC+1</li> </ul> <p>Lorsqu'il n'y a pas d'interruption, le MicroPC se branche directement sur l'adresse du Fetch/Decode (0x08), il n'y a donc pas de surco\u00fbt \u00e0 d\u00e9tecter si une interruption est lev\u00e9e ou non. Si il y a une interruption, la prochaine instruction en ROM[0x01] branchera vers les micro-instructions de l'instruction INT (0xe0).</p> <p>Si une interruption est d\u00e9tect\u00e9e, il faut g\u00e9rer l'interruption. La gestion de l'interruption se fait par les micro-instructions \u00e0 l'adresse 0xe0 (INT). On va supposer ici que notre interruption n'est pas masquable, non interruptible. Aussi, je vous rappelle qu'une interruption doit \u00eatre g\u00e9r\u00e9e de mani\u00e8re transparente pour le programme qui est entrain de tourner, c'est \u00e0 dire qu'il faut sauvegarder les registres avant de partir vers le programme de l'interruption, qu'il faudra recharger apr\u00e8s la routine d'interruption (RTI). Enfin, le programme ex\u00e9cut\u00e9 lors de l'interruption sera ici par convention \u00e0 l'adresse 0x0002 en RAM. Le microcode pour INT devra donc :</p> <ul> <li>mettre \u00e0 z\u00e9ro le registre IF, accuser r\u00e9ception de l'interruption (signal de contr\u00f4le INTA)</li> <li>sauvegarder les registres (A, B, PC) sur la pile</li> <li>charger le PC avec l'adresse 0x0002</li> </ul> <p>On dira alors qu'on est en parti en interruption. Les vecteurs d'interruptions seront cod\u00e9s en RAM avec des instructions JMP. En assembleur, le d\u00e9but de votre RAM devra donc ressembler \u00e0:</p> <pre><code>0x0000    JMP init\n0x0002    JMP handler\n</code></pre> <p>avec init l'adresse de votre programme principal et handler l'adresse du programme \u00e0 ex\u00e9cuter lorsque l'interruption est lev\u00e9e (notez que \"JMP handler\" doit ici \u00eatre \u00e0 l'adresse 0x0002).</p> <p>Le programme associ\u00e9 \u00e0 l'interruption s'ex\u00e9cute alors (par exemple, il modifie la valeur d'une variable en RAM). A la fin du programme d'interruption, il faut revenir au programme interrompu en invoquant l'instruction RTI (ReTurn from Interrupt). Il faut donc remettre le chemin de donn\u00e9es dans l'\u00e9tat dans lequel il \u00e9tait avant le d\u00e9part en interruption, c'est \u00e0 dire:</p> <ul> <li>r\u00e9cup\u00e9rer les registres de la pile</li> <li>r\u00e9activer les interruptions en mettant \u00e0 un le registre IF</li> </ul> <p>Les \u00e9tapes de d\u00e9part en interruption, ex\u00e9cution du programme d'interruption et de retour d'interruption sont illustr\u00e9es ci-dessous.</p> <p></p> <p>Question</p> <p>Travail \u00e0 r\u00e9aliser</p> <p>Commencez par modifier la ROM \u00e0 l'adresse 0x00 pour ajouter les micro-instructions permettant de sauter \u00e0 l'adresse INT (0xe0) si une interrution est lev\u00e9e et de sauter \u00e0 l'adresse des micro-instructions de Fetch/Decode (0x08),</p> <p>D\u00e9finissez le microcode pour les instructions STI (0xd4) , CLI (0xd0),</p> <p>D\u00e9finissez le microcode pour les instructions INT (0xe0) et RTI (0xe8). </p> <p>Testez votre architecture avec le programme suivant irq_bouton_simple.asm, irq_bouton_simple.mem. Le programme principal incr\u00e9mente un compteur, l'interruption alterne 0, 1 sur le deuxi\u00e8me afficheur</p> <p>Pour faciliter votre travail de calcul des micro-instructions, je vous propose d'utiliser  la table de g\u00e9n\u00e9ration de micro-instructions</p> <p></p> <p>Pour faciliter votre travail, je vous propose ci-dessous un outil qui permet des signaux de contr\u00f4le du chemin de donn\u00e9es au code hexad\u00e9cimal de la micro-instruction et vice-versa. </p> <p>Vous pouvez passer alors \u00e0 un probl\u00e8me un peu plus compliqu\u00e9.</p> <p>Question</p> <p>Je vous propose aussi le programme irq_bouton.asm, irq_bouton.mem qui incr\u00e9mente un compteur r\u00e9initialis\u00e9 (en principe) chaque fois qu'on appui sur le bouton. </p> <p>En pratique, si vous testez bien, \u00e7a ne marche pas tout le temps et le compteur n'est pas toujours r\u00e9initialis\u00e9 comme on pense qu'il devrait l'\u00eatre. </p> <p>Savez-vous pourquoi ? Savez vous modifier le programme pour garantir que le compteur soit correctement r\u00e9initialis\u00e9 ?</p>"},{"location":"irq/#une-application-des-interruptions-un-controleur-clavier","title":"Une application des interruptions : un contr\u00f4leur clavier","text":"<p>Je vous propose une application des interruptions en ajoutant un clavier et un \u00e9cran \u00e0 notre architecture. On aimerait que les caract\u00e8res saisis sur le clavier (le clavier s'utilise en tapant des caract\u00e8res tandis que le clavier est s\u00e9lectionn\u00e9 avec le poke tool) soient affich\u00e9s \u00e0 l'\u00e9cran. Dans votre architecture archi_irq.circ :</p> <ul> <li>le clavier est accessible en lecture \u00e0 l'adresse 0x1003, </li> <li>l'\u00e9cran est accessible en \u00e9criture \u00e0 l'adresse 0x1004. </li> </ul> <p></p> <p>Lorsqu'un caract\u00e8re est saisi sur le clavier, une interruption est lev\u00e9e. L'interface avec le clavier est faite de telle sorte qu'\u00e0 la r\u00e9ception du signal INTA, le caract\u00e8re saisi est transf\u00e9r\u00e9 dans un registre tampon. </p> <p>Pour l'\u00e9cran, chaque fois qu'on \u00e9crit un caract\u00e8re \u00e0 l'adresse 0x1004, ce caract\u00e8re est \u00e9crit \u00e0 la suite des caract\u00e8res pr\u00e9c\u00e9dents. </p> <p>Question</p> <p>Travail \u00e0 r\u00e9aliser</p> <p>Ecrivez la RAM telle que le programme principal ex\u00e9cute un programme, par exemple incr\u00e9mente un compteur en affichant le r\u00e9sultat sur un des afficheurs 7 s\u00e9gments, et l'interruption affiche les caract\u00e8res saisis au clavier sur l'\u00e9cran. </p>"},{"location":"irq/#gestion-de-plusieurs-interruptions","title":"Gestion de plusieurs interruptions","text":"<p>Danger</p> <p>sujet \u00e0 \u00e9laborer</p> <p>Voir pour s'inspirer du Intel 8259. Sur le principe de ce composant, on pourrait mettre en place un petit circuit de logique combinatoire pour accepter, par exemple, 8 lignes d'interruptions, avec \u00e9ventuellement un arbitrage fix\u00e9 ou tournant (rotating priority) et un masquage </p> <p>Le circuit sortirait l'offset du vecteur d'interruption sur l'\u00e9tiquette ReadINTADDr plut\u00f4t qu'une adresse fix\u00e9e en dur \u00e0 0x0002</p>"},{"location":"ordonnanceur/","title":"Programmation assembleur et ordonnancement (TP 5)","text":""},{"location":"ordonnanceur/#programmation-assembleur-et-ordonnancement-tp-5","title":"Programmation assembleur et ordonnancement (TP 5)","text":""},{"location":"ordonnanceur/#introduction","title":"Introduction","text":"<p>Ce sujet contient deux parties. Dans une premi\u00e8re partie nous introduisons un assembleur qui permet d'\u00e9crire des programmes en langage d'assemblage, ce qui est beaucoup plus pratique que de les \u00e9crire en langage machine. C'est un premier pas vers les langages de haut niveau qui rendent l'utilisation d'ordinateur plus confortable. Dans une seconde partie, nous nous int\u00e9resserons \u00e0 l'utilisation des interruptions pour ex\u00e9cuter \"en parall\u00e8le\" plusieurs programmes. Nous n'avons ici plus de nouvelles instructions ni de modification du chemin de donn\u00e9es, l'architecture que nous avons construite jusque l\u00e0 dispose de tout ce qu'il nous faut : archi_irq.circ et csmetz.jar, microcode_ordonnanceur.rom.</p> <p>L'architecture est repr\u00e9sent\u00e9e ci-dessous et je vous rappelle que vous disposez de la carte de r\u00e9f\u00e9rence de l'architecture.</p> <p></p>"},{"location":"ordonnanceur/#programmation-assembleur","title":"Programmation assembleur","text":"<p>La programmation en langage machine est assez fastidieuse pour plusieurs raisons :</p> <ul> <li>il faut se souvenir des codes machines (0x10, 0x14, ..) des instructions qu'il est plus difficile de retenir que les \"mn\u00e9moniques\" (LDAi, LDAd, ...)</li> <li>il faut calculer \u00e0 la main les adresses lors des branchements alors qu'on pourrait baliser un programme d'\u00e9tiquettes qu'un assembleur r\u00e9\u00e9crirait</li> <li>il faut d\u00e9terminer \u00e0 la main les adresses ou stocker la pile, les variables globales, .... alors qu'un programme pourrait d\u00e9terminer l'agencement de la m\u00e9moire automatiquement au regard de la taille du programme.</li> </ul> <p>Je vous propose d'introduire un langage d'assemblage ainsi qu'un programme python assemble.py qui convertit le langage d'assemblage en image m\u00e9moire \u00e0 charger directement dans la RAM. Le programme en langage d'assemblage est \u00e9crit avec les mn\u00e9moniques de la fa\u00e7on suivante :</p> <pre><code>LDAi 3\nSTA  1001\n...\n</code></pre> <p>Chaque ligne contient au plus une instruction. Les valeurs qui suivent les instructions doivent \u00eatre hexad\u00e9cimales. Le langage d'assemblage accepte les commentaires, pr\u00e9fix\u00e9s de \";\" :</p> <pre><code>LDAi 3  ; ceci est un commentaire : on charge 3 dans le registre A\n</code></pre> <p>On peut utiliser des \u00e9tiquettes pour r\u00e9f\u00e9rencer des lignes du programme :</p> <pre><code>      JMP init\n      JMP bouton\ninit: LDSPi @stack@\n      STI\n      LDAi 1\n      LDBi 1\nloop: ADDA\n      STA  1001\n      JMP loop\n</code></pre> <p>Le mot clef \"@stack@\" est r\u00e9serv\u00e9. Il est remplac\u00e9, par le script python, par l'adresse de la pile que l'assembleur a calcul\u00e9e. Si vous souhaitez placer la pile vous-m\u00eame, rien ne vous emp\u00eache de ne pas utiliser le mot-clef <code>@stack@</code>. Si vous avez besoin de stocker des variables globales en m\u00e9moire, vous utiliserez la pseudo instruction <code>DSW</code> qui r\u00e9serve un mot m\u00e9moire et lui associe une \u00e9tiquette :</p> <pre><code>DSW compteur\nLDAi 0\nSTA  compteur\n</code></pre> <p>Par convention, on allouera les variables globales au d\u00e9but du programme, apr\u00e8s les vecteurs d'interruptions. Il est interdit d'utiliser des noms de variable ou des \u00e9tiquettes qui peuvent s'interpr\u00e9ter comme une valeur hexad\u00e9cimale. Par exemple, vous ne pouvez pas \u00e9crire</p> <pre><code>DSW ff\n</code></pre> <p>La disposition en m\u00e9moire de la pile et des variables globales est r\u00e9alis\u00e9e par notre assembleur assemble.py de la mani\u00e8re suivante :</p> <pre><code>...\n0x0ffb &lt;--- PILE\n0x0ffc &lt;--- PILE\n0x0ffd &lt;--- PILE\n0x0ffe &lt;--- variable globale 2\n0x0fff &lt;--- variable globale 1\n0x1000 &lt;--- cette adresse r\u00e9f\u00e9rence le premier afficheur\n</code></pre> <p>Dans l'exemple ci-dessus, on a suppos\u00e9 que deux variables globales avaient \u00e9t\u00e9 d\u00e9finies, le pointeur de pile calcul\u00e9 sera alors @stack@=0x0ffd. En effet, l'assembleur s'arrangera toujours pour placer la pile \u00e0 l'adresse la plus \u00e9lev\u00e9e adressable en RAM, avant les variables globales.</p> <p>Pour traduire le programme assembleur en code machine, on invoquera le script assemble.py en passant en argument le nom du script assembleur et le nom du fichier m\u00e9moire cible:</p> <pre><code>user@machine:~$ python3 assemble.py monscript.asm monscript.mem\n</code></pre> <p>Le fichier monscript.mem est alors g\u00e9n\u00e9r\u00e9 et peut \u00eatre directement charg\u00e9 en RAM sauf si des erreurs ont \u00e9t\u00e9 produites pendant l'assemblage. Par exemple, le programme un_compteur.asm qui incr\u00e9mente un compteur et l'affiche se r\u00e9\u00e9crit en un_compteur.mem une fois assembl\u00e9.</p> <p>Question</p> <p>Travail \u00e0 r\u00e9aliser</p> <p>Pour vous faire la main avec la programmation assembleur, je vous propose d'\u00e9crire les programmes ci-dessous en assembleur et les traduire en langage machine avec le script python.</p> <ul> <li>\u00e9tendez un_compteur.asm pour prendre en compte les interruptions. Appuyer sur le bouton doit incr\u00e9menter un second compteur, ind\u00e9pendant du premier, dont la valeur sera affich\u00e9e sur le troisi\u00e8me afficheur,</li> <li>r\u00e9\u00e9crivez en assembleur les programmes qui calculent la suite de syracuse et la factorielle</li> </ul>"},{"location":"ordonnanceur/#ordonnanceur","title":"Ordonnanceur","text":"<p>Supposons que vous ayez besoin d'ex\u00e9cuter plusieurs programmes de mani\u00e8re simultan\u00e9e, par exemple surfer sur internet en m\u00eame temps que vous imprimez un document. Vous n'avez certainement pas envie d'attendre que l'impression se termine pour pouvoir r\u00e9cup\u00e9rer la main sur la machine pour continuer de surfer sur Internet. Comme notre machine est mono-coeur, il faut disposer d'un moyen d'allouer alternativement le chemin de donn\u00e9es \u00e0 l'un et l'autre des programmes \u00e0 ex\u00e9cuter. C'est le r\u00f4le de l'ordonnanceur (scheduler). On va ici voir une version assez frustre d'ordonnancement mais qui donnera n\u00e9anmoins l'illusion que deux programmes tournent en parall\u00e8le. Pour cela, il faut allouer alternativement le processeur \u00e0 l'un ou l'autre des programmes (on pourrait consid\u00e9rer plus que deux programmes).</p> <p>Ce qui va nous int\u00e9resser ici c'est la commutation de contexte. Le contexte est d\u00e9fini par l'\u00e9tat de tous les registres A, B, PC. En fait, toute l'astuce va consister \u00e0 changer la valeur du pointeur de pile et les m\u00e9canismes introduits jusqu'\u00e0 maintenant de d\u00e9part et de retour d'interruption vont faire le reste du travail.</p> <p>On souhaite ex\u00e9cuter deux programmes qu'on appelle programme0 et programme1.Supposons qu'un premier programme soit entrain de tourner (on verra un peu plus loin comment initialiser le syst\u00e8me). Ce programme est entrain de tourner avec sa propre pile, appelons l\u00e0 pile0. Lorsque l'interruption est lev\u00e9e, le d\u00e9part en interruption sauvegarde les registres sur pile1 puis le vecteur d'interruption sched est appel\u00e9. Supposons \u00e9galement que la pile d'un second programme, appelons l\u00e0 pile1 contienne au sommet un contexte (A, B, PC). Si on change la valeur du pointeur de pile de pile0 \u00e0 pile1, alors le retour d'interruption RTI va d\u00e9piler le contexte de pile1 et, ce faisant, reprendre l'ex\u00e9cution du programme1, comme illustr\u00e9 sur la figure ci-dessous : </p> <p></p> <p>Il reste la question de savoir comment initialiser la machine. Pour que l'ordonnanceur puisse faire son travail, il doit disposer de 3 variables :</p> <ul> <li>current : l'identifiant du programme en cours d'ex\u00e9cution (0 ou 1)</li> <li>sp0 : la valeur du pointeur de pile lors de la derni\u00e8re transition programme0 vers programme1</li> <li>sp1 : la valeur du pointeur de pile lors de la derni\u00e8re transition programme1 vers programme0</li> </ul> <p>Le mot m\u00e9moire current indique l'identifiant du programme en cours d'ex\u00e9cution et sp0 et sp1 contiennent les adresses des piles pour les deux programmes. La phase d'initialisation de la machine doit initialiser ces trois mots. Le probl\u00e8me principal dans l'initilisation consiste \u00e0 s'assurer que, si on commence par lancer programme0, lorsque l'ordonnanceur est r\u00e9veill\u00e9 par l'interruption, il y ait un contexte \u00e0 d\u00e9piler dans pile1. Une premi\u00e8re approche consiste \u00e0 empiler des valeurs arbitraires pour les registres A et B et l'adresse du point d'entr\u00e9e du programme1 qu'on \u00e9tiquettera main1 et, \u00e0 la fin de la phase d'initialisation de brancher sur le point d'entr\u00e9e main0 (JMP main0). \u00c7a marche mais \u00e7a n'est pas tr\u00e8s \u00e9l\u00e9gant parce que l'initialisation de pile0 et de pile1 n'est pas sym\u00e9trique. Une deuxi\u00e8me solution consiste \u00e0 voir l'initialisation comme une interruption. On empile alors un contexte (A, B, PC=main0) sur pile0 et (A, B, PC=main1) sur pile1, le pointeur de pile \u00e0 sp0 et current \u00e0 0 et on finit la phase d'initialisation par un retour d'interruption RTI. Avec cette approche, l'initialisation des deux piles est sym\u00e9trique et le retour d'interruption lance l'ex\u00e9cution du premier programme. La phase d'initialisation donnerait par exemple : </p> <p></p> <p>Question</p> <p>Travail \u00e0 r\u00e9aliser</p> <p>Ecrivez et testez un programme assembleur qui fait tourner deux programmes :</p> <ul> <li>le premier programme incr\u00e9mente un compteur de 1 en 1 et affiche le r\u00e9sultat sur le premier afficheur</li> <li>le second programme incr\u00e9mente un compteur de 2 en 2 et affiche le r\u00e9sultat sur le deuxi\u00e8me afficheur</li> </ul> <p>Pour faciliter votre travail, je vous propose un squelette de m\u00e9moire scheduling_squelette.asm. Une fois que vous \u00eates convaincus que votre impl\u00e9mentation fonctionne, modifiez le c\u00e2blage de l'architecture pour que les interruptions soient g\u00e9n\u00e9r\u00e9es par un timer plut\u00f4t que par le bouton. Le circuit timer.circ permet de g\u00e9n\u00e9rer une interruption \u00e0 intervalle de temps r\u00e9gulier. N'h\u00e9sitez pas non plus \u00e0 remplacer les deux programmes par, par exemple, la factorielle et syracuse.</p>"},{"location":"ordonnanceur/#pour-aller-plus-loin","title":"Pour aller plus loin","text":""},{"location":"ordonnanceur/#programmation-assembleur-avancee","title":"Programmation assembleur avanc\u00e9e","text":"<p>Danger</p> <p>proposer quelques exercices de programmation ASM</p>"},{"location":"ordonnanceur/#extension-de-lordonnanceur-a-n-processus-concurrents","title":"Extension de l'ordonnanceur \u00e0 \\(N\\) processus concurrents","text":"<p>Question</p> <p>Si vous avez termin\u00e9, \u00e9tendez le principe \u00e0 l'ex\u00e9cution de N programmes. L'allocation du temps CPU se fera en appliquant l'algorithme de Round-Robin.</p>"},{"location":"routines/","title":"Pile et appel de routines (TP 3)","text":""},{"location":"routines/#pile-et-appel-de-routines-tp-3","title":"Pile et appel de routines (TP 3)","text":"<p>Le but de ce BE est d'\u00e9tudier une extension de l'architecture des s\u00e9ances pr\u00e9c\u00e9dentes pour g\u00e9rer l'appel de sous-programmes. On va voir notamment:</p> <ul> <li>le registre Stack Pointer (SP) et la zone m\u00e9moire r\u00e9serv\u00e9e \u00e0 la pile dans la RAM</li> <li>les instructions permettant de manipuler la pile</li> <li>le codage en language assembleur et l'ex\u00e9cution de fonctions r\u00e9cursives</li> </ul> <p>L'architecture que je vous propose d'utiliser est repr\u00e9sent\u00e9e ci-dessous. Vous y verrez notamment l'ajout d'un registre (Stack Pointer) ainsi que deux signaux de contr\u00f4le SetSP et ReadSP qui permettent l'acc\u00e8s en lecture et \u00e9criture du registre. </p> <p>T\u00e9l\u00e9chargez le fichier archi_routines.circ ainsi que le fichier csmetz.jar \u00e0 placer dans le m\u00eame r\u00e9pertoire que votre circuit. Ouvrez le circuit avec logisim. Chargez la ROM microcode_routines.rom qui contient les micro-instructions des instructions introduites dans le sujet pr\u00e9c\u00e9dent.</p> <p>Je vous rappelle que vous disposez de la carte de r\u00e9f\u00e9rence de l'architecture. </p> <p></p>"},{"location":"routines/#instructions-de-manipulation-de-la-pile-et-de-son-pointeur-peek-push-pop-incsp-et-decsp","title":"Instructions de manipulation de la pile et de son pointeur <code>PEEK</code>, <code>PUSH</code>, <code>POP</code>, <code>INCSP</code> et <code>DECSP</code>","text":"<p>Le registre de pile (SP , Stack Pointer) est introduit dans le chemin de donn\u00e9es. On introduit \u00e9galement de nouvelles instructions qui permettent de g\u00e9rer la pile.</p> Code Instruction (8 bits) Nom de l'instruction Nombre de mots Description 0x80 LDSPi 2 Charge la valeur de l'op\u00e9rande dans le registre SP. SP := op\u00e9rande. 0x84 LDSPd 2 Charge la valeur dans la RAM point\u00e9e par l'op\u00e9rande dans le registre SP. SP := Mem[op\u00e9rande. 0x8c STSP 2 Sauvegarde en m\u00e9moire la valeur du registre SP \u00e0 l'adresse donn\u00e9e par l'op\u00e9rande. Mem[op\u00e9rande] := SP 0x90 INCSP 1 Incr\u00e9mente le pointeur de pile. SP := SP + 1 0x94 DECSP 1 D\u00e9cr\u00e9mente le pointeur de pile. SP := SP - 1 0xb0 PUSHA 1 Empile le registre A. Mem[SP] := A; SP := SP - 1 0xb4 POPA 1 D\u00e9pile le registre A. SP := SP + 1; A := Mem[SP] 0xb8 POKEA 2 Sauvegarde le registre A dans la pile. Mem[SP+operande] := A 0xbc PEEKA 2 R\u00e9cup\u00e8re le registre A dans la pile. A := Mem[SP + operande] 0xc0 PUSHB 1 Empile le registre B. Mem[SP] := B; SP := SP - 1 0xc4 POPB 1 D\u00e9pile le registre B. SP := SP + 1; B := Mem[SP] 0xc8 POKEB 2 Sauvegarde le registre B dans la pile. Mem[SP+operande] := B 0xcc PEEKB 2 R\u00e9cup\u00e8re le registre B dans la pile. B := Mem[SP + operande] <p>Il est important de s'assurer qu'apr\u00e8s chaque instruction (non pas micro-instruction bien s\u00fbr), le pointeur de pile pointe la prochaine zone m\u00e9moire libre de la pile. Je vous rappelle aussi que la pile augmente dans le sens des adresses d\u00e9croissantes; c'est la raison pour laquelle, par exemple, r\u00e9cup\u00e9rer une variable dans la pile (PEEKA ou PEEKB) se fait en ajoutant un d\u00e9calage au pointeur de pile. Tout \u00e7a est illustr\u00e9 ci-dessous. </p> <p></p> <p>Question</p> <p>Ecrivez les micro-instructions des instructions ci-dessus. </p> <p>Pour faciliter votre travail, je vous propose ci-dessous un outil qui permet de passer des signaux de contr\u00f4le du chemin de donn\u00e9es au code hexad\u00e9cimal de la micro-instruction et vice-versa. </p> <p>Table de g\u00e9n\u00e9ration de micro-instructions</p> <p>Vous remarquerez l'introduction de deux champs pour contr\u00f4ler le registre de pointeur de pile (SP). </p> <p>Question</p> <p>Testez votre architecture avec le programme stack.mem. Si tout se passe bien, vos afficheurs et votre RAM (regardez bien les adresses 0x1e, 0x1f et 0x20) devraient donner : </p> <p></p> <p>Tip</p> <p>N'h\u00e9sitez pas \u00e0 retranscrire le code machine en utilisant le nom des op\u00e9rations pour plus facilement d\u00e9couvrir ce que ces programmes doivent faire. Par exemple :</p> <pre><code>8000 20\n9400\n1000 3\n1c00 1000\nb000\n... \n</code></pre> <p>peut se voir de mani\u00e8re \u00e9quivalente comme :</p> <pre><code>LDSPi 0x0020\nDECSP\nLDAi  0x0003\nSTA   0x1000\nPUSHA\n...\n</code></pre>"},{"location":"routines/#instructions-de-depart-et-retour-de-routines-call-et-ret","title":"Instructions de d\u00e9part et retour de routines <code>CALL</code> et <code>RET</code>","text":"<p>On va maintenant voir une utilisation int\u00e9ressante de la pile lors de l'appel de routines, et en particulier le passage d'arguments et de la valeur de retour d'une routine. Il nous suffit d'introduire deux instructions pour l'appel d'une routine (CALL) et le retour d'une routine (RET) : </p> Code Instruction (8 bits) Nom de l'instruction Nombre de mots Description 0xa0 CALL 2 Empile le compteur de programme (PC) et branche \u00e0 l'adresse de la routine fournie par l'op\u00e9rande 0xa8 RET 2 D\u00e9pile le compteur de programme (PC) de la pile <p>Pour se rappeler la mani\u00e8re dont l'appel de routine fonctionne, je vous propose de consid\u00e9rer l'appel d'une fonction :</p> <pre><code>f(a, b) = a + b\n</code></pre> <p>Cette fonction doit disposer des op\u00e9randes \"a\" et \"b\", calculer son op\u00e9ration et retourner le r\u00e9sultat au programme appelant. En supposant par example que le programme appelant appelle f(7,8), on aurait par exemple le code suivant en RAM, ici \u00e9crit en assembleur pour \u00eatre plus lisible:</p> <pre><code># Programme appelant :\n0x0000     LDSPi 0x0030\n0x0002     DECSP          # On r\u00e9serve de la place dans la pile pour la valeur de retour\n0x0003     LDAi  0x0007\n0x0005     PUSHA          # On charge la premi\u00e8re op\u00e9rande\n0x0006     LDAi  0x0008\n0x0008     PUSHA          # On charge la deuxi\u00e8me op\u00e9rande\n0x0009     CALL 0x0020    # On appelle la routine\n0x000b     POPA           # On enl\u00e8ve la deuxi\u00e8me op\u00e9rande de la pile\n0x000c     POPA           # On enl\u00e8ve la premi\u00e8re op\u00e9rande de la pile\n0x000d     POPA           # On r\u00e9cup\u00e8re le r\u00e9sultat\n0x000e     STA  0x1000    # On affiche le r\u00e9sultat\n0x0010     END            # Fin de programme\n\n# Routine \u00e0 l'adresse 0x0020:\n0x0020     PEEKA 0x0003   # On r\u00e9cup\u00e8re la premi\u00e8re op\u00e9rande\n0x0022     PEEKB 0x0002   # On r\u00e9cup\u00e8re la seconde op\u00e9rande\n0x0024     ADDA           # On en fait la somme\n0x0025     POKEA 0x0004   # On sauvegarde le r\u00e9sultat\n0x0027     RET            # On retourne au programme appelant\n</code></pre> <p>Pour qu'\u00e0 la sortie de la routine (RET), on sache quelle adresse charger dans le compteur de programme (PC), l'instruction CALL sauvegarde la valeur courante du PC apr\u00e8s avoir lu son op\u00e9rande, i.e. l'adresse de l'instruction qui suit le CALL. Il faut bien faire attention \u00e0 prendre en compte que l'adresse de retour est mise dans la pile lorsqu'on calcule les d\u00e9calages des instructions PEEK et POKE. En image, \u00e7a nous donne une \u00e9volution de la pile ci-dessous :</p> <p></p> <p>L'adresse de retour empil\u00e9e par le CALL est la valeur du PC apr\u00e8s lecture de l'op\u00e9rande du CALL. Lorsqu'on ex\u00e9cute les micro-instructions du CALL, le PC pointe sur son op\u00e9rande; Faites donc bien attention \u00e0 sauvegarder l'adresse de retour PC+1 dans la pile. </p> <p>Question</p> <p>Je vous propose le travail suivant :</p> <ul> <li>introduisez les micro-instructions pour les instructions CALL (0xa0) et RET (0xa8),</li> <li>programmez votre RAM pour ex\u00e9cuter l'exemple illustratif ci-dessus et tester votre impl\u00e9mentation.</li> </ul> <p>Pour vous aider dans votre travail , pensez \u00e0 utiliser la :</p> <p>Table de g\u00e9n\u00e9ration de micro-instructions</p> <p>Danger</p> <p>Assurez vous que vos impl\u00e9mentations des instructions <code>CALL</code> et <code>RET</code> sont fonctionnelles avant de passer \u00e0 la suite. Par exemple, vous pouvez utiliser le code d'exemple mentionn\u00e9 pr\u00e9c\u00e9demment mais vous pouvez \u00e9galement \u00e9crire votre propre programme \u00e0 charger en RAM.</p> <p>Une fois que vous \u00eates assur\u00e9s que votre architecture est fonctionnelle, je vous propose deux exercices . </p> <p>Question</p> <p>Pour commencer je vous propose de programmer une g\u00e9n\u00e9ralisation des suites de Syracuse (ou de Collatz)</p> \\[\\begin{eqnarray} u(n+1) &amp;=&amp; f(u(n), a, b)\\\\ f(u, a, b) &amp;=&amp; \\begin{cases} \\frac{u}{2} &amp; \\text{ si } u \\text{ est pair } \\\\ a u + b &amp; \\text{ sinon } \\end{cases} \\end{eqnarray}\\] <p>Je vous propose d'\u00e9crire un programme permettant de calculer les valeurs de cette suite en \u00e9crivant une routine pour la fonction \"f\".</p> <p>Question</p> <p>Ecrivez \u00e9galement une routine qui calcule la factorielle d'un nombre et utilisez le pour calculer \\(8!\\). Pour rappel : </p> \\[ fac(n) = \\begin{cases} 1 &amp; \\text{ si } n = 0\\\\ n fac(n-1) &amp; \\text{ sinon } \\end{cases} \\] <p>On voit donc que, si n est non nul, le r\u00e9sultat de fact(n) est calcul\u00e9 \u00e0 partir du r\u00e9sultat de fact(n-1); nous avons donc ici une fonction r\u00e9cursive. </p>"},{"location":"seq_man/","title":"S\u00e9quenceur manuel (TP 1)","text":""},{"location":"seq_man/#sequenceur-manuel-tp-1","title":"S\u00e9quenceur manuel (TP 1)","text":""},{"location":"seq_man/#introduction","title":"Introduction","text":"<p>Le but de ce premier TP est d'introduire un chemin de donn\u00e9es qu'on va utiliser tout au long du cours et des TPs. On introduit progressivement des \u00e9l\u00e9ments de logique combinatoire et de logique s\u00e9quentielle avec le but utiltime de cette s\u00e9ance d'\u00eatre capable de piloter \u00e0 la main le chemin de donn\u00e9es pour lui faire r\u00e9aliser quelques op\u00e9rations. Nous verrons durant les s\u00e9ances suivantes comment automatiser le pilotage du chemin de donn\u00e9es ainsi que quelques extensions de ce chemin de donn\u00e9es. On va voir notamment:</p> <ul> <li>l'unit\u00e9 arithm\u00e9tique et logique</li> <li>les registres</li> <li>la m\u00e9moire RAM (Random Access Memory)</li> <li>le s\u00e9quencement du chemin de donn\u00e9es</li> </ul> <p>Logisim est install\u00e9 sur les postes de travail. Lisez la page principale pour savoir comment le d\u00e9marrer plus 2/3 autres indications.</p>"},{"location":"seq_man/#charger-des-registres-et-effectuer-des-operations-arithmetiques","title":"Charger des registres et effectuer des op\u00e9rations arithm\u00e9tiques","text":""},{"location":"seq_man/#lancement-de-logisim-et-chargement-de-larchitecture","title":"Lancement de logisim et chargement de l'architecture","text":"<p>On consid\u00e8re dans un premier temps l'architecture ci-dessous. T\u00e9l\u00e9chargez les fichiers csmetz.jar et archi_seq_man_regual.circ et placez les dans le m\u00eame r\u00e9pertoire. Lancez logisim et chargez le fichier archi_seq_man_regual.circ. L'architecture charg\u00e9e est repr\u00e9sent\u00e9e ci-dessous.</p> <p>Avant de jouer avec cette architecture, je vous propose de d\u00e9crire rapidement quelques \u00e9l\u00e9ments de l'interface logisim. </p> <p></p> <p>Note</p> <p>L'annotation de l'image ci-dessus a \u00e9t\u00e9 r\u00e9alis\u00e9e gr\u00e2ce \u00e0 annotely.</p> <p>Vos outils principaux dans ce TP sont le \"poke tool\" et l'horloge. Le poke tool, la petite main en haut \u00e0 gauche de l'interface, permet de modifier la valeur des entr\u00e9es, cliquer sur les boutons, .... L'horloge est activ\u00e9e en appuyant sur les touches Ctrl + t, le petit symbole de l'horloge indiquant si elle est \u00e0 un niveau haut ou bas. Appuyer sur Ctrl + t d\u00e9clenche une transition de niveau bas vers niveau haut ou niveau haut vers niveau bas, il faut donc presser deux fois ces touches pour produire un cycle d'horloge.</p>"},{"location":"seq_man/#presentation-de-larchitecture","title":"Pr\u00e9sentation de l'architecture","text":"<p>L'architecture propos\u00e9e est constitu\u00e9e :</p> <ul> <li>de signaux de contr\u00f4le : des entr\u00e9es modifiables avec le <code>poke tool</code>, et un bouton <code>Clear</code> pour r\u00e9initialiser le contenu des registres,</li> <li>d'une entr\u00e9e pour les donn\u00e9es labelis\u00e9e Data, tout \u00e0 gauche. Son contenu est modifi\u00e9 avec le <code>poke tool</code>,</li> <li>de deux registres A et B actifs sur front montant d'horloge,</li> <li>d'une Unit\u00e9 Arithm\u00e9tique et Logique,</li> <li>d'une sortie avec quelques afficheurs 7 s\u00e9gments et un registre m\u00e9morisant la valeur \u00e0 afficher (le convertisseur ToBCD est un circuit de logique combinatoire convertissant un nombre binaire en binaire cod\u00e9 d\u00e9cimal pour l'affichage).</li> </ul> <p>La circulation des donn\u00e9es sur les bus A, B et S est autoris\u00e9e par des buffers contr\u00f4l\u00e9s par un signal de contr\u00f4le particulier. </p> <p>Example</p> <p>Pour charger le registre A, il faut :</p> <ul> <li>placer des donn\u00e9es sur le bus S, </li> <li>autoriser le chargement du registre (SetA), </li> <li>d\u00e9clencher un front montant d'horloge.</li> </ul> <p>En plus des signaux Zero (Z), Retenue (Carry) et de d\u00e9bordement (V), l'UAL fournit 12 op\u00e9rations d\u00e9crites dans la table ci-dessous: </p> U3 U2 U1 U0 Op\u00e9ration 0 0 0 0 S = A 0 0 0 1 S = B 0 0 1 0 S = A ET B 0 0 1 1 S = A OU B 0 1 0 0 S = non(A) 0 1 0 1 S = non(B) 0 1 1 0 S = A + B 0 1 1 1 S = A - B 1 0 0 0 S = A + 1 1 0 0 1 S = A - 1 1 0 1 0 S = A * B 1 0 1 1 S = A &gt;&gt; 1 S = Erreur <p>Question</p> <p>Travail \u00e0 r\u00e9aliser</p> <p>En utilisant les signaux de contr\u00f4le et l'entr\u00e9e Data uniquement (!), r\u00e9alisez les op\u00e9rations suivantes les unes apr\u00e8s les autres. Je vous conseille de remettre \u00e0 z\u00e9ro tous les signaux de contr\u00f4le avant de passer \u00e0 l'instruction suivante.</p> <ul> <li>charger la valeur d\u00e9cimale 16 dans le registre A</li> <li>charger la valeur d\u00e9cimale 12 dans le registre B</li> <li>afficher le contenu du registre A sur les afficheurs 7 s\u00e9gments</li> <li>afficher le contenu du registre B sur les afficheurs 7 s\u00e9gments</li> <li>sommer le contenu des registres A et B et stocker le r\u00e9sultat dans le registre A</li> <li>stocker dans A le r\u00e9sultat de la division enti\u00e8re par deux (une op\u00e9ration de l'UAL permet de le faire, si si) du contenu du registre A et l'afficher simultan\u00e9ment sur les afficheurs 7 s\u00e9gments</li> <li>Est ce que vous obtenez le r\u00e9sultat attendu sur l'afficheur ?</li> </ul>"},{"location":"seq_man/#connecter-le-chemin-de-donnees-avec-une-memoire-ram","title":"Connecter le chemin de donn\u00e9es avec une m\u00e9moire RAM","text":"<p>On introduit maintenant une m\u00e9moire dans le chemin de donn\u00e9es depuis laquelle on va charger des donn\u00e9es et dans laquelle on va \u00e9galement \u00e9crire des donn\u00e9es. Cette nouvelle architecture est archi_seq_man.circ. Le chemin de donn\u00e9es est modifi\u00e9 en ajoutant une RAM et deux registres : </p> <ul> <li>PC (Program counter) et,</li> <li>RADM (Registre d'ADresse M\u00e9moire).</li> </ul> <p>Quelques afficheurs 7-segments sont \u00e9galement disponibles.</p> <p></p> <p>Des signaux de contr\u00f4le additionnels ont \u00e9galement fait leur apparition : <code>SetPC</code>, <code>ReadPC</code>, <code>SetRADM</code> qui permettent de piloter les entr\u00e9es/sorties des nouveaux registeres.</p> <p>La RAM ainsi que les afficheurs sont adressables. Cela veut dire qu'on peut lire/\u00e9crire dans la RAM ainsi qu'\u00e9crire dans les afficheurs. Pour une lecture (en RAM donc), on r\u00e9alise les \u00e9tapes suivantes :</p> <ol> <li>placer l'adresse du mot \u00e0 lire dans le registre RADM, </li> <li>d\u00e9clencher la lecture avec le signal ReadMem, qui va placer le contenu de la    RAM sur le bus B.</li> </ol> <p>Pour une \u00e9criture (en RAM ou sur un afficheur), on proc\u00e9dera par :</p> <ol> <li>placer l'adresse du mot \u00e0 \u00e9crire dans le registre RADM, </li> <li>placer les donn\u00e9es \u00e0 \u00e9crire sur le bus S et</li> <li>d\u00e9clencher l'\u00e9criture avec le signal SetMem.</li> </ol> <p>Les afficheurs sont dits mapp\u00e9s en m\u00e9moire (on verra un plus en d\u00e9tails ce que cela signifie plus tard), c'est \u00e0 dire qu'ils ont des adresses particuli\u00e8res:</p> <ul> <li>Si le contenu de RADM est inf\u00e9rieur strict \u00e0 0x1000, on adresse la RAM,</li> <li>Si le contenu de RADM vaut 0x1000, 0x1001 ou 0x1002 on adresse respectivement le premier, deuxi\u00e8me et troisi\u00e8me afficheur.</li> </ul> <p>Example</p> <p>Ne vous laissez pas d\u00e9router par le plat de spaghettis de connexions autour de la m\u00e9moire et des afficheurs.</p> <p>En pratique, si je veux afficher le contenu du registre A sur le premier afficheur, je proc\u00e9derais ainsi :</p> <ol> <li>mettre 0x1000 dans RADM pour adresser le premier afficheur</li> <li>Lire A (ReadA), rediriger A vers S (UAL=0000), et \u00e9crire en m\u00e9moire (SetMem)</li> </ol> <p>Si je veux charger, dans le registre A, le contenu de la RAM \u00e0 l'adresse 0x0010, je proc\u00e9derais ainsi :</p> <ol> <li>mettre 0x0010 dans RADM</li> <li>Lire la m\u00e9moire (ReadMem), rediriger B vers S (UAL=0001), et \u00e9crire dans le registre A (SetA)</li> </ol> <p>Si je veux \u00e9crire le contenu du registre A dans la RAM \u00e0 l'adresse 0x0010, je proc\u00e9derais ainsi :</p> <ol> <li>mettre 0x0010 dans RADM</li> <li>Lire A (ReadA), rediriger A vers S (UAL=0000), et \u00e9crire en m\u00e9moire (SetMem)</li> </ol> <p>Dans le travail que je propose de r\u00e9aliser, nous allons charger des op\u00e9randes en m\u00e9moire (plus tard, on ajoutera \u00e9galement les instructions) \u00e0 partir d'un fichier (bouton droit sur la RAM, \"charger l'image\" et choisir par example seq_man.mem ou bien en \u00e9ditant directement la RAM (bouton droit sur la RAM, \"\u00e9diter le contenu\"). </p> <p>Question</p> <p>Chargez l'image en m\u00e9moire seq_man.mem et regardez ensuite le contenu de la RAM. Il doit \u00eatre :</p> <p>0010 1000 000c 1001 1002</p> <p>Ces valeurs correspondent aux op\u00e9randes dont vous allez avoir besoin par la suite.</p> <p>Les op\u00e9randes vont \u00eatre consid\u00e9r\u00e9es les unes apr\u00e8s les autres (dans la question suivante, vous comprendrez pourquoi nous avons mis ces valeurs particuli\u00e8res). Pour savoir quelle est l'adresse de l'op\u00e9rande en m\u00e9moire actuellement consid\u00e9r\u00e9e, nous utilisons le regisgtre Program Counter (PC). Pour r\u00e9cup\u00e9rer une op\u00e9rande dont l'adresse est dans le PC, il suffit de transf\u00e9rer le PC dans le registre RADM et de lire la m\u00e9moire. Chaque fois qu'une op\u00e9rande est utilis\u00e9e, on devra incr\u00e9menter le program counter. </p> <p>Question</p> <p>Travail \u00e0 r\u00e9aliser</p> <p>En utilisant uniquement les signaux de contr\u00f4le (donc on ne modifie pas les registres \"\u00e0 la main\"), et apr\u00e8s avoir charg\u00e9 l'image seq_man.mem dans la RAM, effectuez les op\u00e9rations ci-dessous. Je vous conseille de prendre des notes des signaux de contr\u00f4le que vous utilisez pour chaque \u00e9tape. Notez que pour chacune des op\u00e9rations ci-dessous, les op\u00e9randes sont plac\u00e9es dans la RAM.</p> <ol> <li>charger la valeur d\u00e9cimale 16 dans le registre A</li> <li>afficher le contenu du registre A sur le premier afficheur</li> <li>charger la valeur d\u00e9cimale 12 dans le registre B</li> <li>afficher le contenu du registre B sur le second afficheur</li> <li>soustraire le contenu du registre B au contenu du registre A et stocker le r\u00e9sultat dans le registre A</li> <li>afficher le contenu du registre A sur le trois\u00e8me afficheur</li> </ol> <p>On se propose d\u00e9sormai de travailler sur un deuxi\u00e8me exemple. Je vous propose de proc\u00e8de comme pr\u00e9c\u00e9demment, en d\u00e9finissant votre contenu de RAM et en orchestrant manuellement le chemin de donn\u00e9es via les signaux de contr\u00f4le. </p> <p>Question</p> <p>Travail \u00e0 r\u00e9aliser</p> <p>Modifiez le contenu de la m\u00e9moire et ex\u00e9cutez le programme avec les signaux de contr\u00f4le permettant de faire les divisions par deux successives de 128 jusqu'\u00e0 un r\u00e9sultat nul. Affichez le r\u00e9sultat de chaque \u00e9tape sur l'afficheur 7 segments. </p> <p>Quel signal me permet de d\u00e9tecter qu'il faut s'arr\u00eater ? </p> <p>Dans ce dernier exemple, on commence \u00e0 voir appara\u00eetre une boucle. Nous introduirons prochainement des instructions, et en particulier des instructions de saut conditionnel (<code>JZA</code> et <code>JZB</code>) qui utilisent les signaux \u00e9mis par l'UAL pour d\u00e9router le fil d'ex\u00e9cution s\u00e9quentiel d'un programme.</p>"},{"location":"seq_micro/","title":"S\u00e9quence micro-programm\u00e9 (TP 2)","text":""},{"location":"seq_micro/#sequence-micro-programme-tp-2","title":"S\u00e9quence micro-programm\u00e9 (TP 2)","text":""},{"location":"seq_micro/#introduction","title":"Introduction","text":"<p>Le but de ce TL est de r\u00e9aliser un s\u00e9quenceur micro-programm\u00e9 pour piloter notre architecture repr\u00e9sent\u00e9e ci-dessous. Nous allons voir qu'un nouveau composant est introduit, une ROM, et votre travail consiste alors \u00e0 \u00e9crire le micro-code de quelques instructions dans cette ROM. Plusieurs programmes vous sont fournis pour tester votre r\u00e9alisation et vous aurez \u00e9galement \u00e0 \u00e9crire vos propres programmes en code machine. Lancez logisim et chargez l'architecture archi_sequenceur.circ ainsi que le fichier csmetz.jar \u00e0 placer dans le m\u00eame r\u00e9pertoire que archi_sequenceur.circ. Lisez ensuite la pr\u00e9sentation ci-dessous avec l'architecture sous les yeux.</p> <p></p> <p>La m\u00e9moire RAM contient des mots de 16 bits et est adressable sur 16 bits et a donc une capacit\u00e9 de 128 Ko. Les op\u00e9randes et les adresses sont cod\u00e9es sur 16 bits. Les instructions sont cod\u00e9es sur un ou deux mots de 16 bits : le premier mot contient le code de l'op\u00e9ration et l'\u00e9ventuel mot suivant contient l'op\u00e9rande. Le code de l'op\u00e9ration est cod\u00e9 dans les 8 bits de poids fort d'un mot. Ce qui se r\u00e9sum\u00e9 sur le tableau ci-dessous donnant la s\u00e9mantique des bits d'un ou deux mots de 16 bits.</p> 151413121110 9 8 7 6 5 4 3 2 1 0 Code de l'op\u00e9ration -- bits inutilis\u00e9s --  151413121110 9 8 7 6 5 4 3 2 1 0 Op\u00e9rande (optionelle) <p>Les instructions \u00e0 disposition sont list\u00e9es dans la table ci-dessous :</p> Code op\u00e9ration (8 bits) Nom de l'op\u00e9ration Nombre de mots Description 0x0c END 1 Fin de programme 0x10 LDAi 2 Charge la valeur de l'op\u00e9rande dans le registre A  [A := operande] 0x14 LDAd 2 Charge la valeur dans la RAM point\u00e9e par l'op\u00e9rande dans le registre A. [A := Mem[op\u00e9rande]] 0x18 - - - 0x1c STA 2 Sauvegarde en m\u00e9moire la valeur du registre A \u00e0 l'adresse donn\u00e9e par l'op\u00e9rande. [Mem[op\u00e9rande] := A] 0x20 LDBi 2 Charge la valeur de l'op\u00e9rande dans le registre B [B := operande] 0x24 LDBd 2 Charge la valeur dans la RAM point\u00e9e par l'op\u00e9rande dans le registre B. [B := Mem[op\u00e9rande]] 0x28 - - - 0x2c STB 2 Sauvegarde en m\u00e9moire la valeur du registre B \u00e0 l'adresse donn\u00e9e par l'op\u00e9rande. [Mem[op\u00e9rande] := B] 0x30 ADDA 1 Ajoute le contenu des registres A et B et m\u00e9morise le r\u00e9sultat dans le registre A. [A := A + B] 0x34 ADDB 1 Ajoute le contenu des registres A et B et m\u00e9morise le r\u00e9sultat dans le registre B. [B := A + B] 0x38 SUBA 1 Soutstrait le contenu des registres A et B et m\u00e9morise le r\u00e9sultat dans le registre A. [A := A - B] 0x3c SUBB 1 Soutstrait le contenu des registres A et B et m\u00e9morise le r\u00e9sultat dans le registre B. [B := A - B] 0x40 MULA 1 Multiplie le contenu des registres A et B et m\u00e9morise le r\u00e9sultat dans le registre A. [A := A x B] 0x44 MULB 1 Multiplie le contenu des registres A et B et m\u00e9morise le r\u00e9sultat dans le registre B. [B := A x B] 0x48 DIVA 1 Divise le contenu du registre A par deux et m\u00e9morise le r\u00e9sultat dans A. [A := A / 2] 0x4c - - 0x50 ANDA 1 Calcule un ET logique entre le contenu des registres A et B et m\u00e9morise le r\u00e9sultat dans A. [A := A &amp; B] 0x54 ANDB 1 Calcule un ET logique entre le contenu des registres A et B et m\u00e9morise le r\u00e9sultat dans B. [B := A &amp; B] 0x58 ORA 1 Calcule un OU logique entre le contenu des registres A et B et m\u00e9morise le r\u00e9sultat dans A. [A := A 0x5c ORB 1 Calcule un OU logique entre le contenu des registres A et B et m\u00e9morise le r\u00e9sultat dans B. [B := A 0x60 NOTA 1 M\u00e9morise dans A la n\u00e9gation de A. [A := !A] 0x64 NOTB 1 M\u00e9morise dans B la n\u00e9gation de B. [B := !B] 0x68 - - 0x6c - - 0x70 JMP 2 Saute inconditionnellement \u00e0 l'adresse donn\u00e9e par l'op\u00e9rande. [PC := operande] 0x74 JZA 2 Saute \u00e0 l'adresse donn\u00e9e par l'op\u00e9rande si le contenu du registre A est nul. [PC := operande si A=0] 0x78 JZB 2 Saute \u00e0 l'adresse donn\u00e9e par l'op\u00e9rande si le contenu du registre B est nul. [PC := operande si B=0] 0x7c - -"},{"location":"seq_micro/#presentation-du-chemin-de-donnees","title":"Pr\u00e9sentation du chemin de donn\u00e9es","text":"<p>Le chemin de donn\u00e9es est constitu\u00e9 de diff\u00e9rents \u00e9l\u00e9ments que je vous propose de d\u00e9tailler.</p>"},{"location":"seq_micro/#memoire-ram","title":"M\u00e9moire RAM","text":"<p>La m\u00e9moire contient les instructions et les donn\u00e9es du programme \u00e0 ex\u00e9cuter. Elle est adressable par le registre RADM (Registre d'Adresse M\u00e9moire); Pour lire la m\u00e9moire, il faut d'abord placer l'adresse du mot m\u00e9moire \u00e0 lire dans le registre d'adresse m\u00e9moire (RADM). Pour cela, il faut placer l'adresse sur le bus S, activer le registre d'adresse m\u00e9moire <code>SetRADM=1</code> et activer un front montant d'horloge. En mettant la m\u00e9moire en lecture <code>ReadMem=1</code>, le mot m\u00e9moire \u00e0 l'adresse contenue dans le registre RADM est imm\u00e9diatement disponible sur la sortie.</p> <p></p> <p>Pour modifier le contenu de la m\u00e9moire, il faut d'abord mettre dans le registre d'adresse m\u00e9moire (RADM) l'adresse \u00e0 laquelle l'information doit \u00eatre stock\u00e9e. Ensuite, il faut placer l'information \u00e0 stocker sur le bus S, mettre la m\u00e9moire en mode \u00e9criture SetMem=1 et activer un front montant d'horloge. Le mot disponible sur l'entr\u00e9e D sera alors sauvegard\u00e9e \u00e0 l'adresse contenue dans le registre RADM au prochain front montant d'horloge. </p>"},{"location":"seq_micro/#adressage-des-afficheurs-7-segments","title":"Adressage des afficheurs 7 segments","text":"<p>L'utilisation des afficheurs 7 segments se fait en adressant la m\u00e9moire \u00e0 des adresses particuli\u00e8res. Les adresses, sur 16 bits, inf\u00e9rieures strict \u00e0 0x1000 adressent la RAM; Les trois afficheurs ont respectivement les adresses 0x1000, 0x1001 et 0x1002. Pour afficher une valeur sur le premier afficheur, il faut placer l'adresse 0x1000 dans le registre RADM, puis faire comme si on sauvegardait une valeur en m\u00e9moire : placer la valeur sur le bus S, mettre la m\u00e9moire en \u00e9criture (SetMem) et d\u00e9clencher un front montant d'horloge.</p> <p>Le composant combinatoire ToBCD (Binaire Cod\u00e9 D\u00e9cimal) assure la traduction d'un entier cod\u00e9 en binaire sur 16 bits en son codage BCD sur 20 bits pour ensuite afficher chacun des 5 chiffres sur un afficheur 7 segments. Pour information, ce composant peut impl\u00e9menter l'algorithme du double dabble.</p>"},{"location":"seq_micro/#unite-arithmetique-et-logique","title":"Unit\u00e9 Arithm\u00e9tique et Logique","text":"<p>L'unit\u00e9 arithm\u00e9tique et logique re\u00e7oit ses op\u00e9randes des bus A et B. Son op\u00e9ration est d\u00e9finie par l'\u00e9tat de l'entr\u00e9e Code_UAL. L'UAL est un circuit combinatoire donc lorsque le code op\u00e9ration est d\u00e9finie, la sortie est \"imm\u00e9diatement\" disponible (en r\u00e9alit\u00e9, modulo le temps de transit des signaux dans l'UAL). L'UAL comporte \u00e9galement 3 indicateurs Z, C, V:</p> <ul> <li>Z : indicateur de r\u00e9sultat nul, Z=1 si S=0</li> <li>C : indicateur de retenue, C=1 si une retenue appara\u00eet lors du calcul de S</li> <li>V : indicateur de d\u00e9bordement, V=1 si le calcul de S produit un d\u00e9bordement</li> </ul> <p></p> <p>L'UAL fournit 11 op\u00e9rations d\u00e9crites dans la table ci-dessous</p> Code UAL (4 bits) Op\u00e9ration 0000 S = A 0001 S = B 0010 S = A ET B 0011 S = A OU B 0100 S = non(A) 0101 S = non(B) 0110 S = A + B 0111 S = A - B 1000 S = A + 1 1001 S = A - 1 1010 S = A x B 1011 S = A &gt;&gt; 1"},{"location":"seq_micro/#registres-doperandes-et-program-counter","title":"Registres d'op\u00e9randes et Program Counter","text":"<p>Les registres A, B et program counter sont accessibles en lecture et en \u00e9criture. Pour \u00e9crire dans ces registres, il suffit de placer une valeur sur le bus S, de les activer SetA, SetB, SetPC et de d\u00e9clencher un front montant d'horloge. Pour lire les donn\u00e9es, il suffit d'activer les portes de sorties, ReadA, ReadB, ReadPC. Attention, les registres A et PC mettent leur sortie sur le bus A mais le registre B sort sur le bus B.</p> <p></p>"},{"location":"seq_micro/#sequence-microprogramme","title":"S\u00e9quence microprogramm\u00e9","text":"<p>Le s\u00e9quenceur microprogramm\u00e9 re\u00e7oit en entr\u00e9e le code de l'instruction sur 8 bits (les 8 bits du poids fort du mot m\u00e9moire). Programmer le s\u00e9quenceur consiste \u00e0 d\u00e9finir la s\u00e9quence des signaux (micro-instructions) pilotant le chemin de donn\u00e9es pour chacune des instructions. La code de l'instruction (e.g. 0x10 pour LDAi) adresse directement la ROM de telle sorte que la s\u00e9quence de micro-instructions pour l'instruction LDAi commence \u00e0 l'adresse 0x10 de la ROM. Comme vous pouvez le remarquer, entre chaque code instruction, il y a un offset de 4 mots, ce qui veut dire que vous devez coder chaque instruction par une s\u00e9quence d'au plus 4 micro-instructions. Pour remplir la ROM, il suffit de faire un clic droit sur la ROM et d'aller dans le menu \"Edit Content\". Attention: dans la version de logisim que nous utilisons le copier/coller est bugg\u00e9; le contenu coll\u00e9 est malheureusement toujours coll\u00e9 en d\u00e9but de m\u00e9moire. Vous avez la possibilit\u00e9 d'\u00e9diter le fichier m\u00e9moire avec un \u00e9diteur de texte et de charger son contenu ensuite dans la ROM (clic droit sur la ROM, \"Load image\"). On va revenir sur ce point dans la partie \"Conseil de mise en oeuvre\" \u00e0 la fin du sujet.</p> <p>La disposition des instructions dans la ROM vous est impos\u00e9e.</p> <ul> <li>A l'adresse 0x00, vous devez sauter \u00e0 l'adresse 0x08 qui contient les micro-instructions pour les phases de Fetch/Decode. Nous utiliserons dans un sujet ult\u00e9rieur cette zone m\u00e9moire diff\u00e9remment, pour y placer les interruptions,</li> <li>A l'adresse 0x08 se trouvent les micro-instructions de la phase de Fetch/Decode,</li> <li>A l'adresse 0x0c se trouvent les micro-instructions pour l'instruction END,</li> <li>A l'adresse 0x10 se trouvent les micro-instructions pour l'instruction LDAi, </li> <li>puis \u00e0 l'adrese 0x14 pour l'instruction LDAd, </li> <li>etc..</li> </ul> <p></p> <p>Une micro-instruction est un mot sur 32 bits, les 24 premiers bits pilotant le chemin de donn\u00e9es, les 8 derniers bits codant une adresse essentiellement utilis\u00e9e pour les branchements. Sch\u00e9matiquement, une micro-instruction a donc le format suivant : </p> <p></p> <p>Il nous reste \u00e0 expliquer le r\u00f4le du champ sur 3 bits CodeMCount et de l'adresse sur 8 bits Adr. Les 3 bits CodeMCount sont combin\u00e9s avec la sortie Z de l'UAL pour piloter le multiplexeur en entr\u00e9e du registre d'adresse de micro-instruction MicroPC. Notons SMux la sortie du multiplexeur, le composant qui interface CodeMCount, Z et le multiplexeur agit ainsi: </p> <ul> <li>Si CodeMCount=0b000, alors SMux=MicroPC+1</li> <li>Si CodeMCount=0b001, alors SMux=@Adr</li> <li>Si CodeMCount=0b010, alors SMux=InstCode</li> <li>Si CodeMCount=0b011 et Z=0, alors SMux=MicroPC+1</li> <li>Si CodeMCount=0b011 et Z=1, alors SMux=@Adr</li> </ul> <p>Le registre micro PC est au s\u00e9quenceur en ROM ce que le program counter est au programme en RAM : il permet de l'adresser et de savoir quelle micro-instruction ex\u00e9cuter. Pour certaines instructions (e.g. JZA), il est n\u00e9cessaire de sauter plusieurs mots dans la ROM. Pour simplifier le nombre de composants, il a \u00e9t\u00e9 choisi de pr\u00e9ciser dans la micro-instruction l'adresse du saut:</p> <ul> <li>pour ce TP, la premi\u00e8re micro-instruction de la ROM, i.e. \u00e0 l'adresse 0x00, doit faire sauter le micro PC \u00e0 l'adresse des microinstructions de fetch/decode : CodeMCount=0b001, @Adr=0x08 soit ROM[0x00]=0x00800008</li> <li>il ne faudra pas oublier de retourner \u00e0 l'adresse 0x00 \u00e0 la fin d'une s\u00e9quence de micro-instruction</li> <li>pour les sauts conditionnels JZA, JZB, on devra utiliser le champ @Adr de la micro-instruction si le test est vrai</li> </ul> <p>Example</p> <p>Prenons par exemple l'instruction de chargement imm\u00e9diat dans le registre A (LDAi, code:0x10). Pour ex\u00e9cuter cette instruction, il faut:</p> <ul> <li>Charger dans le registre d'adresse m\u00e9moire le contenu du registre PC (ReadPC=1, Code UAL=0000 qui correspond \u00e0 l'op\u00e9ration S=A, SetRADM=1). Le code de la microinstruction associ\u00e9e est donc 0x00000c00</li> <li>Mettre la m\u00e9moire en mode lecture (ReadMem = 1), diriger l'entr\u00e9e B vers la sortie S (Code UAL=0001) et activer le registre A en \u00e9criture (SetA = 1). Le code de la microinstruction associ\u00e9e est donc 0x00084100</li> <li>Enfin, il faut incr\u00e9menter le program counter (ReadPC=1, CodeUAL=1000, SetPC=1) et mettre dans le registre micro PC l'adresse du d\u00e9but de la ROM (Adr=0x00, CodeMCount=001). Le code de la microinstruction associ\u00e9e est donc 0x00c01800</li> </ul> <p>L'instruction LDA imm\u00e9diat n\u00e9cessite donc 3 micro-instructions : 0x00000c00, 0x00084100, 0x00c01800.</p>"},{"location":"seq_micro/#travail-a-realiser-programmation-des-micro-instructions","title":"Travail \u00e0 r\u00e9aliser : programmation des micro-instructions","text":"<p>On vous demande d'\u00e9crire le microcode dans la ROM pour chacune des 23 instructions pr\u00e9sent\u00e9es un peu plus haut. La m\u00e9thode consiste \u00e0 prendre les instructions les unes apr\u00e8s les autres et \u00e0 \u00e9crire la s\u00e9quence de codes hexad\u00e9cimaux permettant de r\u00e9aliser l'instruction. Ces codes hexad\u00e9cimaux permettent de configurer le chemin de donn\u00e9es. Les codes d'instructions, d'UAL, ... sont list\u00e9s pr\u00e9c\u00e9demment et \u00e9galement synth\u00e9sis\u00e9s dans la carte de r\u00e9f\u00e9rence.</p> <p>Pour faciliter votre travail de calcul des micro-instructions, je vous propose d'utiliser la table de g\u00e9n\u00e9ration de micro-instructions</p> <p>Comme expliqu\u00e9 dans la partie ci-dessous \"Conseils de mise en oeuvre\", vous partirez du fichier m\u00e9moire microcode_seq.rom. Vous remarquerez que la premi\u00e8re micro-instruction est d\u00e9j\u00e0 mentionn\u00e9e, elle permet de sauter dans la ROM \u00e0 l'adresse des micro-instructions du Fetch/Decode. Les micro-instructions pour l'instruction END sont \u00e9galement d\u00e9j\u00e0 mentionn\u00e9es. Pour pouvoir tester les s\u00e9quences de micro-instruction que vous allez d\u00e9finir, vous trouverez ci-dessous quelques programmes \u00e0 charger dans la RAM. Il faudra toujours cliquer sur le bouton \"Clear\" en haut du circuit pour remettre les registres dans leur \u00e9tat initial avant de tester un programme.</p> <p>Question</p> <p>Je vous propose de coder les instructions dans l'ordre suivant :</p> <ul> <li>renseignez les micro-instructions pour la phase de Fetch/Decode en commen\u00e7ant \u00e0 l'adresse 0x08</li> <li>renseignez les micro-instructions pour les instructions LDAi et STA et testez votre architecture avec le programme LDAiSTA.mem. Vous devriez voir 2025 sur le premier afficheur (pourquoi?),</li> <li>renseignez les micro-instructions pour l'instructions LDAd et testez votre architecture avec le programme LDAdSTA.mem. Vous devriez voir 2025 sur le premier afficheur (pourquoi?),</li> <li>renseignez les micro-instructions pour les instructions LDBi, LDBd, STB, ADDA et testez votre architecture en \u00e9crivant vous m\u00eame un fichier m\u00e9moire de test,</li> <li>renseignez les micro-instructions pour les instructions arithm\u00e9tiques SUB, MUL, .. et logiques AND, OR, .. et adaptez les codes donn\u00e9s pr\u00e9c\u00e9demment pour tester votre architecture,</li> <li>renseignez les micro-instructions pour le saut inconditionnel JMP et testez votre architecture avec le programme JMP.mem. Que vous attendez vous \u00e0 voir ?</li> <li>renseignez les micro-instructions pour le saut conditionnel JZA et JZB et testez votre architecture avec le programme JZ.mem,</li> <li>renseignez les micro-instructions pour l'instruction DIVA et testez votre architecture avec le programme DIV.mem.</li> </ul> <p>Tip</p> <p>Conseil de mise en oeuvre</p> <p>Vous avez la possibilit\u00e9 de modifier le contenu des RAM et ROM depuis logisim. N\u00e9anmoins, je vous conseille de proc\u00e9der diff\u00e9remment. Vous avez en effet la possibilit\u00e9 de charger la m\u00e9moire \u00e0 partir d'un fichier. Je vous propose donc de t\u00e9l\u00e9charger le fichier microcode_seq.rom, de le modifier avec un \u00e9diteur de texte (gedit ou emacs par example) et de le charger ensuite en ROM. Le texte commen\u00e7ant par \"#\" sont des commentaires pour vous aider \u00e0 vous rep\u00e9rer dans la ROM. </p>"},{"location":"seq_micro/#travail-a-realiser-calculer-avec-votre-architecture","title":"Travail \u00e0 r\u00e9aliser : calculer avec votre architecture","text":"<p>Question</p> <p>Calculez la suite de syracuse avec votre architecture en \u00e9crivant le code machine ad\u00e9quat.</p> \\[\\begin{eqnarray} u(0) &amp;=&amp; 127\\\\ u(n+1) &amp;=&amp; \\begin{cases} \\frac{u(n)}{2} &amp; \\text{si } u(n)\\text{ pair} \\\\ 3 u(n) + 1 &amp; \\text{sinon} \\end{cases}  \\end{eqnarray}\\] <p>Affichez les valeurs sur les afficheurs 7 s\u00e9gments (voir par exemple ce site pour v\u00e9rifier les valeurs).... </p> <p>4, 2, 1, 4, 2, 1, mais pourquoi ? </p> <pre><code>\"Les math\u00e9matiques ne sont pas encore pr\u00eates pour de tels probl\u00e8mes [P. Erdos]\"\n</code></pre>"},{"location":"spaceinvaders/","title":"Bonus: place aux jeux","text":""},{"location":"spaceinvaders/#bonus-place-aux-jeux","title":"Bonus: place aux jeux","text":""},{"location":"spaceinvaders/#introduction","title":"Introduction","text":"<p>Jusqu'\u00e0 maintenant, nous avons travaill\u00e9 sur des probl\u00e8mes jouets pour illustrer diff\u00e9rents concepts d'architecture. Je vous propose maintenant de laisser libre court \u00e0 votre imagination et de programmer votre architecture. Rien de tel alors que de se lancer le d\u00e9fi de programmer un jeu. Alors, n'exag\u00e9rons pas, notre architecture est limit\u00e9e \u00e0 bien des \u00e9gards : </p> <ul> <li>la fr\u00e9quence d'horloge qui est d\u00e9pendante de la fr\u00e9quence \u00e0 laquelle notre circuit peut \u00eatre simul\u00e9 n'exc\u00e9dera que difficilement le kHz (nos ordinateurs sont cadenc\u00e9s \u00e0 une fr\u00e9quence 10 000 000 fois plus grande), </li> <li>on va ajouter un petit \u00e9cran de 16x16 pixels monochrome et on va essayer de ne pas \u00eatre exag\u00e9r\u00e9ment ambitieux quand au jeu que nous devons \u00e9crire en assembleur. </li> </ul> <p>Mais soit, faisons avec;</p> <p>Je vous propose d'utiliser l'architecture archi_jeu.circ ainsi que le microcode microcode_jeu.rom.</p> <p></p> <p>Comme nouveaut\u00e9s, j'ai ajout\u00e9 deux nouvelles instructions :</p> <ul> <li>STAB (0x1800) : Place le contenu du registre A \u00e0 l'adresse contenue dans le registre B : Mem[B] := A</li> <li>STBA (0x2800) : Place le contenu du registre B \u00e0 l'adresse contenu dans le registre A : Mem[A] := B</li> </ul> <p>Le programme Python assembleur <code>assemble.py</code> prends en compte ces deux nouvelles instructions. </p> <p>Au niveau des p\u00e9riph\u00e9riques, notre mini console dispose:</p> <ul> <li>d'un clavier, qui signale la pr\u00e9sence d'un caract\u00e8re par interruption son buffer \u00e9tant accessible en lecture \u00e0 l'adresse 0x1003</li> <li>d'un \u00e9cran de 16 x 16 pixels monochromes; un p\u00e9riph\u00e9rique de sortie pour lequel on renseigne le contenu des lignes individuellement. Chaque pixel peut avoir l'\u00e9tat 0 ou 1. Une ligne pleine sera par exemple cod\u00e9e avec la valeur 0xFFFF</li> </ul> <p>L'\u00e9cran est coupl\u00e9 au chemin de donn\u00e9es par l'interm\u00e9diaire d'un composant appel\u00e9 pompeusement \"CarteGraphique\". N'h\u00e9sitez pas \u00e0 cliquer avec le \"Poke Tool\" sur ce composant pour inspecter son contenu. Pour des raisons pratiques de temps de simulation, vous disposez de deux impl\u00e9mentations, l'une purement en logisim, via le composant <code>CGraphicalCard_circ</code>, que vous pouvez inspecter et une autre cod\u00e9e directement en java dont vous ne pouvez pas directement voir les entrailles sous la forme d'un composant logique.</p> <p>Notre carte graphique dispose de deux blocs de buffers, chaque bloc \u00e9tant constitu\u00e9 de 16 registres 16 bits pour d\u00e9finir la couleur de chaque pixel de l'\u00e9cran. Ces deux blocs de buffers constituent ce qu'on appelle du double buffering. Par la suite j'appelle buffer un bloc de 16 registres de 16 bits. </p> <p>On dispose donc de deux buffers. Sans double buffering, puisque chacune des lignes est adress\u00e9e individuellement, on verrait visuellement la mise \u00e0 jour progressive de chaque ligne et le rendu ne serait pas tr\u00e8s agr\u00e9able. Avec le double buffering, l'un de ces buffers, le front buffer, alimente l'\u00e9cran. Pendant ce temps, on \u00e9crit une nouvelle image dans l'autre buffer, le back buffer. Une fois l'image compl\u00e8tement \u00e9crite en m\u00e9moire, on permute le r\u00f4le des front buffer et back buffer. On voit alors d'un coup, la nouvelle image. </p> <p></p> <p>En pratique, le composant CarteGraphique dispose :</p> <ul> <li>d'une adresse de base, \u00e0 fournir sur un bus d'entr\u00e9e, par exemple la constante   0x2000 sur l'architecture qui vous est fournie</li> <li>d'un registre de 1 bit adressable \u00e0 l'adresse 0x2000 qui d\u00e9finit quel buffer est le front buffer et quel buffer est le back buffer</li> <li>de 16 registres 16 bits adressables \u00e0 des adresses 0x2001, 0x2002, 0x2003, ... 0x2010</li> </ul> <p>Warning</p> <p>Vous pouvez utiliser plusieurs \u00e9crans. Ils auront des plages d'adresses d\u00e9pendantes de l'adresse de base que vous fournissez \u00e0 l'entr\u00e9e de votre composant.</p> <p>Si vous changez la constante 0x2000 par une autre valeur de base, les adresses des registres internes sont \u00e0 adapter en cons\u00e9quence.</p> <p>Le registre pour s\u00e9lectionner le buffer est de 1 bit, mais reste aliment\u00e9 via le bus de donn\u00e9es de 16 bits. En interne, seul le bit de poids faible est utilis\u00e9 pour modifier le contenu de ce registre. Donc :</p> <ul> <li>LDAi 0000 ; STA 0x2000 : s\u00e9lectionne le buffer \"de gauche\" en front buffer et le buffer \"de droite\" en back buffer</li> <li>LDAi 0001 ; STA 0x2000 : s\u00e9lectionne le buffer \"de gauche\" en back buffer et le buffer \"de droite\" en front buffer</li> </ul> <p>Pour utiliser ce syst\u00e8me de double buffering, on remplira alors toute l'image en adressant toutes les lignes puis on terminera par permuter les front et back buffers pour d\u00e9clencher l'affichage de l'image. A titre d'illustration, je vous propose ci-dessous une petite vid\u00e9o d'une r\u00e9alisation d'un mini space invaders. Pendant la vid\u00e9o, les tirs sont g\u00e9n\u00e9r\u00e9s en appuyant sur le touche \"L\", les touches \"Q\" et \"D\" d\u00e9placent la plateforme \u00e0 gauche et \u00e0 droite. Soyez patient, la video dure 5 minutes, ... le processeur est cadenc\u00e9 au mieux \u00e0 500 Hz. Je vous donne \u00e9galement le code source en assembleur si vous souhaitez utiliser ce jeu comme point de d\u00e9part.</p>   Download the WEBM video."}]}